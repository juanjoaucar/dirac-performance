import streamlit as st
from pathlib import Path


import base64
import re
from collections import defaultdict


from comparison.loader import load_csvs, load_and_normalize
from comparison.tables import render_static_table, render_selection_table
from comparison.graphs import plot_selected_rows


# Configuración de la página
st.set_page_config(layout="wide")

# Carpeta raíz con los reportes
ROOT = Path("static/html")


# =============================================================================
# TEXTS
# =============================================================================

# Expander text
index_expander_content = """
This Streamlit application is designed to visualize DIRAC performance reports generated by diverse CPUs across a broad range of characteristics. In the sidebar, users can first select the CPU type and then choose different DIRAC builds, which vary in libraries, compilers, and compiler options. Each report includes:
- Main files that identify the key characteristics of the build under inspection.
- A summary table that briefly describes the performance tests and synthesizes their results.
- For each test, a Time vs. Number of cores graph (left) and a RAM vs. Number of cores graph (right).

The performance tests are executed individually on CPUs without other demanding processes active, ensuring the reliability of the results.
"""

# Disable links for imported Index.html files
disable_links_css = """
<style>
a {
    pointer-events: none; /* deshabilita clics */
    color: gray;          /* opcional: cambiar color para indicar que está deshabilitado */
    text-decoration: none;
    cursor: default;
}
</style>
"""

# =============================================================================
# UTILIDADES
# =============================================================================

def file_to_data_url(path: Path) -> str:
    """Convierte cualquier archivo (HTML, imagen, CSS, etc.) en un data URL."""
    mime = {
        ".html": "text/html",
        ".css": "text/css",
        ".js": "text/javascript",
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".gif": "image/gif",
        ".svg": "image/svg+xml",
    }.get(path.suffix.lower(), "application/octet-stream")
    
    data = path.read_bytes()
    b64 = base64.b64encode(data).decode()
    return f"data:{mime};base64,{b64}"

def rewrite_paths(html: str, parent_dir: Path) -> str:
    """Reescribe rutas relativas (href, src, link rel='stylesheet') a data-URLs."""
    pattern = r'(href|src)=["\']([^"\']+)["\']'
    
    def repl(match):
        attr = match.group(1)
        href = match.group(2)
        
        # Ignorar rutas absolutas HTTP/HTTPS
        if href.startswith("http://") or href.startswith("https://"):
            return match.group(0)
        
        # Ruta relativa al archivo actual
        target = (parent_dir / href).resolve()
        if target.exists():
            try:
                return f'{attr}="{file_to_data_url(target)}"'
            except Exception:
                pass
        return match.group(0)
    
    return re.sub(pattern, repl, html)

# =============================================================================
# EXPLORADOR CON SUBCATEGORÍAS POR CARPETA
# =============================================================================

# Construimos un dict: categoria → lista de archivos
categorias = defaultdict(list)
for f in ROOT.rglob("*.html"):
    rel = f.relative_to(ROOT)
    categoria = rel.parts[0] if len(rel.parts) > 1 else "(root)"
    categorias[categoria].append(rel)

# Ordenar categorías alfabéticamente
categorias_ordenadas = dict(sorted(categorias.items()))

# Sidebar
st.sidebar.write("### Explorer for specific CPU and build-type")

# Selección de categoría
cat_sel = st.sidebar.selectbox(
    "Reports:",
    list(categorias_ordenadas.keys())
)

# Archivos de la categoría seleccionada
archivos = categorias_ordenadas[cat_sel]

# Mostrar solo el primer nivel de subdirectorio dentro de la categoría
# Incluye el primer html, cuyos links no funcionan correctamente (no se muestran las imagenes)
archivo_nombres = []
for a in archivos:
    parts = a.parts
    if len(parts) > 1:
        # Solo tomar la carpeta que contiene el archivo, no el archivo en sí
        nombre_mostrar = parts[1]
    else:
        nombre_mostrar = a.name
    archivo_nombres.append(str(nombre_mostrar))


# Mapear lo que se muestra → path real
archivo_map = dict(zip(archivo_nombres, archivos))



# Selección de archivo
archivo_sel = st.sidebar.selectbox(
    "Builds:",
    archivo_nombres
)

# Path real del archivo seleccionado
sel_path = ROOT / archivo_map[archivo_sel]

# =============================================================================
# CARGAR Y PROCESAR HTML SELECCIONADO
# =============================================================================

parent_dir = sel_path.parent
raw_html = sel_path.read_text(encoding="utf-8")

# Reescribir rutas relativas internas (even for Index.html)
# html_rewritten = rewrite_paths(raw_html, parent_dir)


# Reescribir rutas relativas internas (excepto para Index.html), y agregar expander sólo para Index.html
if sel_path.name != "Index.html":
    html_rewritten = rewrite_paths(raw_html, parent_dir)
else:
    # Insertar expander con contenido predefinido
    st.expander("DIRAC performances reports", expanded=True).markdown(index_expander_content)

    # Mostrar el Index.html tal cual, pero deshabilitar los links visualmente. Se inyecta un estilo CSS
    html_rewritten = disable_links_css + raw_html

# Convertir a data URL
encoded = base64.b64encode(html_rewritten.encode()).decode()
data_url = f"data:text/html;base64,{encoded}"


# =============================================================================
# Tables and graphs (comparison tool)
# =============================================================================
import pandas as pd

st.sidebar.write("### Comparison tool")
activar_comp = st.sidebar.checkbox("Activate", value=False)

if activar_comp:
    info = load_csvs(ROOT)
    cpus = sorted({cpu for cpu, build, p in info})
    builds = sorted({build for cpu, build, p in info})

    build_sel = st.sidebar.selectbox("Type of build", builds)
    cpus_sel = st.sidebar.multiselect("CPU Models:", cpus, default=None)

    if cpus_sel:
        st.write(f"## Comparison for build-type: **{build_sel}**")

        tablas = []

        for cpu in cpus_sel:
            match = [p for (cpu_i, build_i, p) in info
                     if cpu_i == cpu and build_i == build_sel]

            if not match:
                st.warning(f"There is no CSV file available for {cpu} and build-type {build_sel}")
                continue


            tablas.append(load_and_normalize(match[0], cpu))

        ### =============================================================================
        ### Static table with data
        ### =============================================================================

        if tablas:
            import pandas as pd
            df_all = pd.concat(tablas, ignore_index=True)

            # ===============================
            # Static Table
            # ===============================
            df_sorted = (
                df_all[["Test", "cores", "CPU", "time [s]", "peak RAM [Mb]"]] # elijo 5 columnas
                .sort_values(["Test", "cores", "CPU"]) #las ordeno
            )

            render_static_table(df_sorted)

        # =============================================================================
        # Table to produce graphs for comparisson
        # =============================================================================

            sel = render_selection_table(df_sorted)

            if sel is not None and len(sel) > 0:
                plot_selected_rows(sel)
            else:
                st.info("Select desired rows to generate the graph for comparison.")


        st.stop()   # Avoid iframe loading
# =============================================================================
# MOSTRAR EN IFRAME
# =============================================================================

st.markdown(
    f'<iframe src="{data_url}" style="width:100%; height:2000px; border:none;"></iframe>',
    unsafe_allow_html=True,
)

