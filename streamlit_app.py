import streamlit as st
from pathlib import Path
import base64
import re
from collections import defaultdict

# Configuración de la página
st.set_page_config(layout="wide")

# Carpeta raíz con los reportes
ROOT = Path("static/html")


# =============================================================================
# TEXTS
# =============================================================================

# Expander text
index_expander_content = """
This Streamlit application is designed to visualize DIRAC performance reports generated by diverse CPUs across a broad range of characteristics. In the sidebar, users can first select the CPU type and then choose different DIRAC builds, which vary in libraries, compilers, and compiler options. Each report includes:
- Main files that identify the key characteristics of the build under inspection.
- A summary table that briefly describes the performance tests and synthesizes their results.
- For each test, a Time vs. Number of cores graph (left) and a RAM vs. Number of cores graph (right).

The performance tests are executed individually on CPUs without other demanding processes active, ensuring the reliability of the results.
"""

# Disable links for imported Index.html files
disable_links_css = """
<style>
a {
    pointer-events: none; /* deshabilita clics */
    color: gray;          /* opcional: cambiar color para indicar que está deshabilitado */
    text-decoration: none;
    cursor: default;
}
</style>
"""

# =============================================================================
# UTILIDADES
# =============================================================================

def file_to_data_url(path: Path) -> str:
    """Convierte cualquier archivo (HTML, imagen, CSS, etc.) en un data URL."""
    mime = {
        ".html": "text/html",
        ".css": "text/css",
        ".js": "text/javascript",
        ".png": "image/png",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".gif": "image/gif",
        ".svg": "image/svg+xml",
    }.get(path.suffix.lower(), "application/octet-stream")
    
    data = path.read_bytes()
    b64 = base64.b64encode(data).decode()
    return f"data:{mime};base64,{b64}"

def rewrite_paths(html: str, parent_dir: Path) -> str:
    """Reescribe rutas relativas (href, src, link rel='stylesheet') a data-URLs."""
    pattern = r'(href|src)=["\']([^"\']+)["\']'
    
    def repl(match):
        attr = match.group(1)
        href = match.group(2)
        
        # Ignorar rutas absolutas HTTP/HTTPS
        if href.startswith("http://") or href.startswith("https://"):
            return match.group(0)
        
        # Ruta relativa al archivo actual
        target = (parent_dir / href).resolve()
        if target.exists():
            try:
                return f'{attr}="{file_to_data_url(target)}"'
            except Exception:
                pass
        return match.group(0)
    
    return re.sub(pattern, repl, html)

# =============================================================================
# EXPLORADOR CON SUBCATEGORÍAS POR CARPETA
# =============================================================================

# Construimos un dict: categoria → lista de archivos
categorias = defaultdict(list)
for f in ROOT.rglob("*.html"):
    rel = f.relative_to(ROOT)
    categoria = rel.parts[0] if len(rel.parts) > 1 else "(root)"
    categorias[categoria].append(rel)

# Ordenar categorías alfabéticamente
categorias_ordenadas = dict(sorted(categorias.items()))

# Sidebar
st.sidebar.write("### Explorer for specific CPU and build-type")

# Selección de categoría
cat_sel = st.sidebar.selectbox(
    "Reports:",
    list(categorias_ordenadas.keys())
)

# Archivos de la categoría seleccionada
archivos = categorias_ordenadas[cat_sel]

# Mostrar solo el primer nivel de subdirectorio dentro de la categoría
# Incluye el primer html, cuyos links no funcionan correctamente (no se muestran las imagenes)
archivo_nombres = []
for a in archivos:
    parts = a.parts
    if len(parts) > 1:
        # Solo tomar la carpeta que contiene el archivo, no el archivo en sí
        nombre_mostrar = parts[1]
    else:
        nombre_mostrar = a.name
    archivo_nombres.append(str(nombre_mostrar))


# Mapear lo que se muestra → path real
archivo_map = dict(zip(archivo_nombres, archivos))



# Selección de archivo
archivo_sel = st.sidebar.selectbox(
    "Builds:",
    archivo_nombres
)

# Path real del archivo seleccionado
sel_path = ROOT / archivo_map[archivo_sel]

# =============================================================================
# CARGAR Y PROCESAR HTML SELECCIONADO
# =============================================================================

parent_dir = sel_path.parent
raw_html = sel_path.read_text(encoding="utf-8")

# Reescribir rutas relativas internas (even for Index.html)
# html_rewritten = rewrite_paths(raw_html, parent_dir)


# Reescribir rutas relativas internas (excepto para Index.html), y agregar expander sólo para Index.html
if sel_path.name != "Index.html":
    html_rewritten = rewrite_paths(raw_html, parent_dir)
else:
    # Insertar expander con contenido predefinido
    st.expander("DIRAC performances reports", expanded=True).markdown(index_expander_content)

    # Mostrar el Index.html tal cual, pero deshabilitar los links visualmente. Se inyecta un estilo CSS
    html_rewritten = disable_links_css + raw_html

# Convertir a data URL
encoded = base64.b64encode(html_rewritten.encode()).decode()
data_url = f"data:text/html;base64,{encoded}"


# =============================================================================
# Tables and graphs (comparison tool)
# =============================================================================
import pandas as pd

st.sidebar.write("### Comparison tool")
activar_comp = st.sidebar.checkbox("Activate", value=False)

if activar_comp:
    # --- Detect csv files ---
    csv_paths = list(ROOT.rglob("benchmark_summary.csv"))

    info = []
    for p in csv_paths:
        rel = p.relative_to(ROOT)
        cpu = rel.parts[0]
        build = rel.parts[1]
        info.append((cpu, build, p))

    cpus = sorted({cpu for cpu, build, p in info})
    builds = sorted({build for cpu, build, p in info})

    build_sel = st.sidebar.selectbox("Type of build", builds)
    cpus_sel = st.sidebar.multiselect("CPU Models:", cpus, default=None)

    if cpus_sel:
        st.write(f"## Comparison for build-type: **{build_sel}**")

        tablas = []

        for cpu in cpus_sel:
            match = [p for (cpu_i, build_i, p) in info
                     if cpu_i == cpu and build_i == build_sel]

            if not match:
                st.warning(f"There is no CSV file available for {cpu} and build-type {build_sel}")
                continue


### =============================================================================
### Static table with data
### =============================================================================

            df = pd.read_csv(match[0])

            # Fill empty rows, filling with previous values
            df = df.ffill()


            # Normalizar y forzar columnas clave
            df["CPU"] = cpu
            df["Test"] = pd.to_numeric(df["Test"], errors="coerce")
            df["cores"] = pd.to_numeric(df["cores"], errors="coerce")

            tablas.append(df)

        if tablas:
            df_all = pd.concat(tablas, ignore_index=True)

            # ===============================
            # Static Table
            # ===============================
            df_sorted = (
                df_all[["Test", "cores", "CPU", "time [s]", "peak RAM [Mb]"]] # elijo 5 columnas
                .sort_values(["Test", "cores", "CPU"]) #las ordeno
            )
            st.write("### Static table")

            # Coloreo
            import seaborn as sns
            # Crear paleta de colores suaves (tantos como CPUs haya)
            cpus = df_sorted["CPU"].unique()
            palette = sns.color_palette("pastel", len(cpus))
            color_map = {cpu: palette[i] for i, cpu in enumerate(cpus)}
            def highlight_cpu(row):
                color = color_map[row["CPU"]]
                return [f"background-color: rgba({int(color[0]*255)}, {int(color[1]*255)}, {int(color[2]*255)}, 0.35)"] * len(row)

            styled = (
                    df_sorted.style
                    .apply(highlight_cpu, axis=1)
                    .format({"Test": "{:.0f}","time [s]": "{:.2f}", "peak RAM [Mb]": "{:.1f}"})
                    )
            st.dataframe(styled,hide_index=True)

# =============================================================================
# Table to produce graphs for comparisson
# =============================================================================


            from st_aggrid import AgGrid, GridOptionsBuilder

            st.write("### Table to generate graphs")
            # Convertir tu df_sorted a un df sin estilos
            df_show = df_sorted.copy()

            # Crear opciones de tabla
            gb = GridOptionsBuilder.from_dataframe(df_show)
            gb.configure_selection(selection_mode="multiple", use_checkbox=True)
            gb.configure_pagination(enabled=True)
            grid_options = gb.build()

            # Mostrar tabla interactiva
            grid_return = AgGrid(
                    df_show,
                    gridOptions=grid_options,
                    update_mode="MODEL_CHANGED",
                    theme="streamlit",
                    height=400,
                    )

            # Filas seleccionadas
            sel = grid_return["selected_rows"]


            import plotly.express as px

            if sel is not None and len(sel) > 0:

                df_sel = pd.DataFrame(sel)

                tests = df_sel["Test"].unique()
                if len(tests) > 1:
                    st.error("Selected rows must belong to the same **Test number**.")
                    st.stop()


                fig = px.bar(
                        df_sel,
                        x="cores",
                        y="time [s]",
                        color="CPU",
                        barmode="group",
                        title="Times for selected rows",
                        )

                # --- Show only the tics corresponding to the selected numbers of cores ---
                cores_selected = sorted(df_sel["cores"].unique())
                fig.update_xaxes(
                        tickmode="array",
                        tickvals=cores_selected,
                        )

                st.plotly_chart(fig, use_container_width=True)


            else:
                st.info("Select desired rows to generate the graph for comparison.")


        st.stop()   # evitar que cargue el iframe
# =============================================================================
# MOSTRAR EN IFRAME
# =============================================================================

st.markdown(
    f'<iframe src="{data_url}" style="width:100%; height:2000px; border:none;"></iframe>',
    unsafe_allow_html=True,
)

