import streamlit as st
from pathlib import Path

import base64
import re
from collections import defaultdict

import io
import zipfile



from comparison.loader import load_csvs, load_and_normalize
from comparison.tables import render_static_table, render_selection_table
from comparison.graphs import plot_selected_rows
from utils.explorer import build_categories, sidebar_selector
from utils.html_loader import load_html_as_data_url
from utils.file_utils import zip_integrity


# Configuración de la página
st.set_page_config(layout="wide")

# Carpeta raíz con los reportes
ROOT = Path("static/html")


# =============================================================================
# TEXTS
# =============================================================================

# Expander text
index_expander_content = """
This Streamlit application is designed to visualize DIRAC performance reports generated by diverse CPUs across a broad range of characteristics. In the sidebar, users can first select the CPU type and then choose different DIRAC builds, which vary in libraries, compilers, and compiler options. Each report includes:
- Main files that identify the key characteristics of the build under inspection.
- A summary table that briefly describes the performance tests and synthesizes their results.
- For each test, a Time vs. Number of cores graph (left) and a RAM vs. Number of cores graph (right).

The performance tests are executed individually on CPUs without other demanding processes active, ensuring the reliability of the results.
"""

# Expander text about uploading reports
index_expander_uploads = """
New reports can be uploaded using the sidebar tool at the bottom.
Simply upload a ZIP file containing the report folder, and it will be extracted into the appropriate location for viewing within the application.
Make sure the ZIP file maintains the correct structure for the reports to be properly recognized.
"""

# Disable links for imported Index.html files
disable_links_css = """
<style>
a {
    pointer-events: none; /* deshabilita clics */
    color: gray;          /* opcional: cambiar color para indicar que está deshabilitado */
    text-decoration: none;
    cursor: default;
}
</style>
"""



# =============================================================================
# Explorer sidebar
# =============================================================================

categorias = build_categories(ROOT)
# Ordenar categorías alfabéticamente
categorias_ordenadas = dict(sorted(categorias.items())) # TAL VEZ NO ES NECESARIO
sel_path = sidebar_selector(categorias_ordenadas, ROOT)

st.sidebar.write("### Comparison tool")
activar_comp = st.sidebar.checkbox("By CPU model", value=False)
activar_build_comp = st.sidebar.checkbox("By build type", value=False)

# Make sure only one tool is active
if activar_comp and activar_build_comp:
    st.sidebar.error("Please activate only one tool at a time.")
    st.stop()



# =============================================================================
# Tables and graphs (comparison tool)
# =============================================================================
import pandas as pd


if activar_comp:
    info = load_csvs(ROOT)
    cpus = sorted({cpu for cpu, build, p in info})
    builds = sorted({build for cpu, build, p in info})

    build_sel = st.sidebar.selectbox("Type of build", builds)
    cpus_sel = st.sidebar.multiselect("CPU Models:", cpus, default=None)

    if cpus_sel:
        st.write(f"## Comparison for build-type: **{build_sel}**")

        tablas = []

        for cpu in cpus_sel:
            match = [p for (cpu_i, build_i, p) in info
                     if cpu_i == cpu and build_i == build_sel]

            if not match:
                st.warning(f"There is no CSV file available for {cpu} and build-type {build_sel}")
                continue


            tablas.append(load_and_normalize(match[0], cpu, build_sel))

        ### =============================================================================
        ### Static table with data
        ### =============================================================================

        if tablas:
            import pandas as pd
            df_all = pd.concat(tablas, ignore_index=True)

            # ===============================
            # Static Table
            # ===============================
            df_sorted = (
                df_all[["Test", "cores", "CPU", "time [s]", "peak RAM [Mb]"]] # elijo 5 columnas
                .sort_values(["Test", "cores", "CPU"]) #las ordeno
            )

            render_static_table(df_sorted)

        # =============================================================================
        # Table to produce graphs for comparisson
        # =============================================================================

            sel = render_selection_table(df_sorted)

            if sel is not None and len(sel) > 0:
                plot_selected_rows(sel)
            else:
                st.info("Select desired rows to generate the graph for comparison.")


        st.stop()   # Avoid iframe loading

# =============================================================================
# Tables and graphs (comparison of builds for a single CPU)
# =============================================================================
import pandas as pd


if activar_build_comp:
    info = load_csvs(ROOT)
    cpus = sorted({cpu for cpu, build, p in info})
    builds = sorted({build for cpu, build, p in info})

    # Selecciono UN solo CPU
    cpu_sel = st.sidebar.selectbox("CPU Model:", cpus)

    # Selecciono VARIOS builds
    builds_sel = st.sidebar.multiselect("Build types:", builds, default=None)

    if builds_sel:
        st.write(f"## Comparison for CPU: **{cpu_sel}**")

        tablas = []

        for build in builds_sel:
            match = [p for (cpu_i, build_i, p) in info
                     if cpu_i == cpu_sel and build_i == build]

            if not match:
                st.warning(f"There is no CSV file available for CPU {cpu_sel} and build-type {build}")
                continue

            tablas.append(load_and_normalize(match[0], cpu_sel, build))

        ### =============================================================================
        ### Static table with data
        ### =============================================================================

        if tablas:
            df_all = pd.concat(tablas, ignore_index=True)

            # Orden y columnas elegidas
            df_sorted = (
                df_all[["Test", "cores", "CPU", "build", "time [s]", "peak RAM [Mb]"]]
                .sort_values(["Test", "cores", "build"])
            )

            render_static_table(df_sorted)

            # =============================================================================
            # Table to produce graphs for comparison
            # =============================================================================
            sel = render_selection_table(df_sorted)

            if sel is not None and len(sel) > 0:
                plot_selected_rows(sel, color_by="build")
            else:
                st.info("Select desired rows to generate the graph for comparison.")

        st.stop()   # Avoid iframe loading




# =============================================================================
#  HTML viewer
# =============================================================================
is_index = sel_path.name == "Index.html"
if is_index:
    st.expander("DIRAC performances reports", expanded=True).markdown(index_expander_content)
    st.expander("How to upload new reports", expanded=False).markdown(index_expander_uploads)

data_url = load_html_as_data_url(sel_path, is_index)
st.markdown(f'<iframe src="{data_url}" style="width:100%; height:2000px; border:none;"></iframe>', unsafe_allow_html=True)



# =============================================================================
#  Upload new report from zip file (drag & drop)
# =============================================================================

import shutil
from pathlib import Path



st.sidebar.write("### Upload a new Report")
uploaded_zip = st.sidebar.file_uploader(
    "Drag & drop a ZIP with your report folder",
    type=["zip"],
    key="upload_report_zip"
)

if uploaded_zip is not None:
    zip_bytes = io.BytesIO(uploaded_zip.read())
    zip_name=zipfile.ZipFile(zip_bytes).namelist()[0]
    zip_integrity(zip_bytes, ROOT) # (Structure) validation is missing



# =============================================================================
#  Clean uploaded temporary reports
# =============================================================================
if st.sidebar.button("Clean uploaded reports"):
    tmp_dirs = st.session_state.get("uploaded_tmp_dirs", [])

    if not tmp_dirs:
        st.sidebar.info("No temporary uploaded reports to remove.")
    else:
        removed = []
        for cpu_dir in tmp_dirs:
            folder_path = ROOT / cpu_dir
            if folder_path.exists() and folder_path.is_dir():
                shutil.rmtree(folder_path)
                removed.append(str(folder_path))

        if removed:
            st.sidebar.success(f"✅ Removed temporary reports:\n- " + "\n- ".join(removed))
        else:
            st.sidebar.warning("No matching folders were found to remove.")

        # Clean list of uploaded temporary directories
        st.session_state["uploaded_tmp_dirs"] = []
